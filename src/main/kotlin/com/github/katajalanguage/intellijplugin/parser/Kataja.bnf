{
  parserClass="com.github.katajalanguage.intellijplugin.parser.KatajaParser"
  parserUtilClass="com.github.katajalanguage.intellijplugin.parser.KatajaParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Kataja"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.katajalanguage.intellijplugin.psi"
  psiImplPackage="com.github.katajalanguage.intellijplugin.psi.impl"

  elementTypeHolderClass="com.github.katajalanguage.intellijplugin.psi.KatajaTypes"
  elementTypeClass="com.github.katajalanguage.intellijplugin.parser.KatajaElementType"
  tokenTypeClass="com.github.katajalanguage.intellijplugin.lexer.KatajaTokenType"
}

katajaFile ::= (whitespaces? inFileStatement*)*

whitespaces ::= (WHITESPACE | COMMENT | endOfStatement)+
simpleWhiteSpace ::= (WHITESPACE | COMMENT | NEW_LINE)+
endOfStatement ::= ';' | NEW_LINE

inFileStatement ::= singleUse | multiUse | field | type | data | interface | clazz
inClassStatement ::= field | method
inMethodStatement ::= return | if | while | for | do | statement | ('break' endOfStatement) | (calc  endOfStatement)

modifier ::= accessModifier? ('final' | 'const' | 'abstract' | 'synchronized' | 'static' | 'volatile' | 'transient' | 'strict' | 'native')*
accessModifier ::= 'public' | 'proteced' | 'private'
dataType ::= primitiveType | complexType
primitiveType ::= PRIMITIVE ('['']')*
complexType ::= IDENTIFIER ('<' complexType '>')? ('['']')*
genericType ::= '<' IDENTIFIER ('extends' IDENTIFIER)? '>'
parameter ::= 'const'? dataType IDENTIFIER
parameterList ::= '(' (parameter (',' parameter)*) ')'

singleUse ::= 'use' simpleWhiteSpace IDENTIFIER ((('/' IDENTIFIER)+ ('from' IDENTIFIER)?) | (('from' IDENTIFIER)?)) ('as' IDENTIFIER)?
multiUse ::= 'use' simpleWhiteSpace IDENTIFIER (',' IDENTIFIER)+ 'from' IDENTIFIER ('/' IDENTIFIER)*
field ::= modifier dataType IDENTIFIER ('=' calc)? endOfStatement
type ::= modifier 'type' IDENTIFIER '=' IDENTIFIER ('|' IDENTIFIER)* endOfStatement
data ::= modifier 'data' IDENTIFIER '=' parameterList
interface ::= modifier 'interface' IDENTIFIER genericType '{' (whitespaces? inClassStatement*)* '}'
clazz ::= modifier 'class' IDENTIFIER genericType ('extends' IDENTIFIER (',' IDENTIFIER)*)? '{' (whitespaces? inClassStatement*)* '}'

method ::= ((modifier dataType IDENTIFIER parameterList) | 'main') (('=' inMethodStatement) | code)
code ::= ('->' inMethodStatement) | ('{' (whitespaces? inMethodStatement*)* '}')

return ::= 'return' calc endOfStatement
if ::= 'if' calc code ('else' 'if' calc code)* ('else' code)? endOfStatement
while ::= 'while' calc code endOfStatement
for ::= 'for' IDENTIFIER 'in' calc code endOfStatement
do ::= 'do' ('{' (whitespace* inMethodStatement*)* '}') while calc endOfStatement
statement ::= ('_' | dataType)? IDENTIFIER '=' calc endOfStatement

calc ::= calcArg (OPERATOR calcArg)*
calcArg ::= (OPERATOR? (value | call)) | ('(' calc ')') | (IDENTIFIER calc)
value ::= NUMBER | CHAR
call ::= callArg ('.' callArg)*
callArg ::= IDENTIFIER ('<' complexType '>')? ('(' (calc (',' calc)*)? ')')? ('[' calc ']')*